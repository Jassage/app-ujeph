// src/store/authStore.ts
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import api from "../services/api";
import { User } from "../types/academic";
import { toast } from "sonner";

interface AuthState {
  user: User | null;
  token: string | null;
  isAuthenticated: boolean;
  loading: boolean;
  error: string | null;
  initialized: boolean;
  lastActivity: number;
  login: (email: string, password: string) => Promise<void>;
  logout: (reason?: string) => void;
  checkAuth: () => Promise<void>;
  clearError: () => void;
  refreshToken: () => Promise<boolean>;
  updateActivity: () => void;
  initialize: () => Promise<void>;
  fetchPotentialDeans: () => Promise<any[]>;
}

// Timeout d'inactivit√© (30 minutes)
const INACTIVITY_TIMEOUT = 30 * 60 * 1000;

// Monitoring d'activit√©
let activityMonitor: NodeJS.Timeout;

const startActivityMonitoring = (logout: (reason: string) => void) => {
  stopActivityMonitoring();

  activityMonitor = setInterval(() => {
    const state = useAuthStore.getState();
    if (
      state.isAuthenticated &&
      Date.now() - state.lastActivity > INACTIVITY_TIMEOUT
    ) {
      logout("Inactivit√© prolong√©e");
    }
  }, 60000); // V√©rifier toutes les minutes
};

const stopActivityMonitoring = () => {
  if (activityMonitor) {
    clearInterval(activityMonitor);
  }
};

// Gestionnaire d'√©v√©nements pour l'activit√© utilisateur
const setupActivityListeners = () => {
  const events = ["mousedown", "mousemove", "keypress", "scroll", "touchstart"];

  const updateActivity = () => {
    const state = useAuthStore.getState();
    if (state.isAuthenticated) {
      state.updateActivity();
    }
  };

  events.forEach((event) => {
    document.addEventListener(event, updateActivity, { passive: true });
  });

  return () => {
    events.forEach((event) => {
      document.removeEventListener(event, updateActivity);
    });
  };
};

export const useAuthStore = create<AuthState>()(
  persist(
    (set, get) => ({
      user: null,
      token: null,
      isAuthenticated: false,
      loading: false,
      error: null,
      initialized: false,
      lastActivity: Date.now(),

      // M√âTHODE D'INITIALISATION - CORRIG√âE
      initialize: async () => {
        const { token, initialized } = get();

        // Si d√©j√† initialis√©, ne rien faire
        if (initialized) {
          console.log("‚úÖ Authentification d√©j√† initialis√©e");
          return;
        }

        console.log("üîÑ Initialisation de l'authentification...");

        if (!token) {
          console.log("‚ùå Aucun token trouv√© dans le store");
          set({
            initialized: true,
            isAuthenticated: false,
            loading: false,
          });
          return;
        }

        try {
          set({ loading: true });
          console.log("üîç V√©rification du token avec le serveur...");

          // Configurer le header d'autorisation
          if (api?.defaults?.headers) {
            api.defaults.headers.common["Authorization"] = `Bearer ${token}`;
          }

          // V√©rifier le token c√¥t√© serveur
          const response = await api.get("/auth/me");
          console.log(
            "‚úÖ Utilisateur r√©cup√©r√© depuis le serveur:",
            response.data
          );

          set({
            user: response.data,
            isAuthenticated: true,
            loading: false,
            error: null,
            initialized: true,
            lastActivity: Date.now(),
          });

          // D√©marrer le monitoring d'activit√©
          startActivityMonitoring(get().logout);
          setupActivityListeners();

          console.log("‚úÖ Authentification initialis√©e avec succ√®s");
        } catch (error: any) {
          console.error("‚ùå Erreur lors de l'initialisation:", error);

          // Nettoyer les donn√©es invalides
          localStorage.removeItem("authToken");
          localStorage.removeItem("userData");

          if (api?.defaults?.headers) {
            delete api.defaults.headers.common["Authorization"];
          }

          set({
            user: null,
            token: null,
            isAuthenticated: false,
            loading: false,
            error: "Session expir√©e",
            initialized: true,
          });

          toast.error("Votre session a expir√©. Veuillez vous reconnecter.");
        }
      },

      // M√âTHODE DE CONNEXION - CORRIG√âE
      login: async (email: string, password: string) => {
        set({ loading: true, error: null });

        try {
          if (!email || !password) {
            throw new Error("Email et mot de passe requis");
          }

          console.log("üîÑ Tentative de connexion avec:", email);

          const response = await api.post("/auth/login", {
            email: email.trim(),
            password,
          });

          const { token, user, expiresIn } = response.data;

          console.log("‚úÖ R√©ponse API re√ßue:", {
            token: token ? "‚úì Pr√©sent" : "‚úó Absent",
            user: user ? "‚úì Pr√©sent" : "‚úó Absent",
            expiresIn,
          });

          if (!token || !user) {
            throw new Error("R√©ponse d'authentification invalide");
          }

          // V√©rifier si le compte est actif ou verrouill√©
          if (user.status && user.status !== "Actif") {
            throw new Error(
              "Votre compte est d√©sactiv√©. Contactez l'administrateur."
            );
          }

          if (user.lockUntil && new Date(user.lockUntil) > new Date()) {
            const unlockDate = new Date(user.lockUntil).toLocaleString("fr-FR");
            throw new Error(`Compte verrouill√© jusqu'au ${unlockDate}`);
          }

          // CORRECTION CRITIQUE : Mettre √† jour le store AVANT le stockage
          set({
            user,
            token,
            isAuthenticated: true,
            loading: false,
            error: null,
            initialized: true, // IMPORTANT : marquer comme initialis√©
            lastActivity: Date.now(),
          });

          // Stockage s√©curis√©
          localStorage.setItem("authToken", token);
          localStorage.setItem("userData", JSON.stringify(user));

          // Configurer les headers API
          if (api?.defaults?.headers) {
            api.defaults.headers.common["Authorization"] = `Bearer ${token}`;
          }

          // D√©marrer le monitoring
          startActivityMonitoring(get().logout);
          setupActivityListeners();

          console.log("‚úÖ Connexion r√©ussie, utilisateur:", user.email);
          toast.success(`Bienvenue ${user.firstName} ${user.lastName} !`);
        } catch (error: any) {
          console.error("‚ùå Erreur de connexion:", error);

          let errorMessage = "Erreur de connexion au serveur";

          if (error.response?.data?.message) {
            errorMessage = error.response.data.message;
          } else if (error.response?.status === 423) {
            errorMessage = "Compte verrouill√© temporairement.";
          } else if (error.response?.status === 401) {
            errorMessage = "Email ou mot de passe incorrect";
          } else if (error.message) {
            errorMessage = error.message;
          }

          // Affichage du nombre de tentatives restantes si disponible
          if (error.response?.data?.remainingAttempts !== undefined) {
            toast.info(
              `Tentatives restantes : ${error.response.data.remainingAttempts}`
            );
          }

          toast.error(errorMessage);

          // Nettoyage en cas d'erreur
          localStorage.removeItem("authToken");
          localStorage.removeItem("userData");

          if (api?.defaults?.headers) {
            delete api.defaults.headers.common["Authorization"];
          }

          set({
            user: null,
            token: null,
            isAuthenticated: false,
            loading: false,
            error: errorMessage,
            initialized: true, // IMPORTANT : m√™me en cas d'erreur
          });

          throw error;
        }
      },

      // M√âTHODE DE D√âCONNEXION
      logout: (reason = "D√©connexion utilisateur") => {
        console.log(`üîí D√©connexion: ${reason}`);

        // Nettoyage s√©curis√©
        if (api?.defaults?.headers) {
          delete api.defaults.headers.common["Authorization"];
        }

        localStorage.removeItem("authToken");
        localStorage.removeItem("userData");

        set({
          user: null,
          token: null,
          isAuthenticated: false,
          loading: false,
          error: null,
          initialized: true,
        });

        // Arr√™ter le monitoring
        stopActivityMonitoring();

        toast.info("Vous avez √©t√© d√©connect√©");
      },

      // V√âRIFICATION D'AUTHENTIFICATION
      checkAuth: async () => {
        console.log("üîç V√©rification de l'authentification...");
        await get().initialize();
      },

      // EFFACER LES ERREURS
      clearError: () => set({ error: null }),

      // RAFRA√éCHISSEMENT DU TOKEN
      refreshToken: async (): Promise<boolean> => {
        const { token } = get();

        if (!token) {
          console.log("‚ùå Aucun token √† rafra√Æchir");
          return false;
        }

        try {
          console.log("üîÑ Rafra√Æchissement du token...");
          const response = await api.post("/auth/refresh", { token });
          const { newToken } = response.data;

          if (api?.defaults?.headers) {
            api.defaults.headers.common["Authorization"] = `Bearer ${newToken}`;
          }

          set({
            token: newToken,
            lastActivity: Date.now(),
          });

          localStorage.setItem("authToken", newToken);
          console.log("‚úÖ Token rafra√Æchi avec succ√®s");
          return true;
        } catch (error) {
          console.error("‚ùå Erreur lors du rafra√Æchissement du token:", error);
          get().logout("Impossible de rafra√Æchir le token");
          return false;
        }
      },

      // MISE √Ä JOUR DE L'ACTIVIT√â
      updateActivity: () => {
        set({ lastActivity: Date.now() });
      },

      // R√âCUP√âRATION DES DOYENS POTENTIELS
      fetchPotentialDeans: async (): Promise<any[]> => {
        try {
          console.log("üîç R√©cup√©ration des doyens potentiels...");
          const response = await api.get("/users/potential-deans");
          console.log("‚úÖ Doyens potentiels r√©cup√©r√©s:", response.data.length);
          return response.data;
        } catch (error) {
          console.error("‚ùå Erreur lors de la r√©cup√©ration des doyens:", error);
          throw new Error("Impossible de charger la liste des doyens");
        }
      },
    }),
    {
      name: "auth-storage",
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        token: state.token,
        user: state.user,
        lastActivity: state.lastActivity,
        initialized: state.initialized, // IMPORTANT : persister l'√©tat d'initialisation
      }),
      // NOTE: On ne utilise plus onRehydrateStorage car il causait des probl√®mes
    }
  )
);

// Export pour utilisation dans les intercepteurs
export const getAuthState = () => useAuthStore.getState();

// Initialisation automatique au chargement de l'application
export const initializeAuthStore = () => {
  console.log("üöÄ Initialisation du store d'authentification...");

  // V√©rifier si on est dans un environnement browser
  if (typeof window !== "undefined") {
    const token = localStorage.getItem("authToken");
    console.log(
      "üìã Token trouv√© dans localStorage:",
      token ? "‚úì Oui" : "‚úó Non"
    );

    if (token) {
      // D√©marrage automatique de l'initialisation
      setTimeout(() => {
        useAuthStore.getState().initialize();
      }, 100);
    } else {
      // Marquer comme initialis√© m√™me sans token
      useAuthStore.setState({
        initialized: true,
        isAuthenticated: false,
        loading: false,
      });
    }
  }
};

// D√©marrer l'initialisation automatique
if (typeof window !== "undefined") {
  initializeAuthStore();
}
