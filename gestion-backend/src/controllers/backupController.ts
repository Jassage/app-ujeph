// controllers/backupController.ts
import { exec } from "child_process";
import { promisify } from "util";
import fs from "fs";
import path from "path";
import { Request, Response } from "express";
import { AuditService } from "../services/auditService";
import prisma from "../prisma";
import { createConnection } from "mysql2/promise";

const execAsync = promisify(exec);

export const createBackup = async (req: Request, res: Response) => {
  let connection;

  try {
    const { name, modules } = req.body;
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const backupDir = path.join(__dirname, "../../backups");

    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    const dbUrl = process.env.DATABASE_URL;
    if (!dbUrl) {
      return res.status(500).json({ error: "DATABASE_URL non configurée" });
    }

    const sqlFilename = name
      ? `backup-${name.replace(/[^a-zA-Z0-9]/g, "-")}-${timestamp}.sql`
      : `backup-academic-${timestamp}.sql`;

    const sqlFilePath = path.join(backupDir, sqlFilename);

    console.log(`🔧 Création de la sauvegarde MySQL (Node.js): ${sqlFilename}`);

    // Extraire les informations de connexion
    const urlMatch = dbUrl.match(
      /mysql:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/
    );
    if (!urlMatch) {
      throw new Error("Format DATABASE_URL MySQL invalide");
    }

    const [, username, password, host, port, database] = urlMatch;

    // Créer une connexion
    connection = await createConnection({
      host,
      port: parseInt(port),
      user: username,
      password,
      database,
      charset: "utf8mb4",
    });

    let sqlContent = `-- MySQL dump generated by Academic System\n`;
    sqlContent += `-- Server version: Node.js MySQL2\n`;
    sqlContent += `-- Database: ${database}\n`;
    sqlContent += `-- Generation Time: ${new Date().toISOString()}\n\n`;
    sqlContent += `SET FOREIGN_KEY_CHECKS=0;\n\n`;

    // Récupérer la liste des tables
    const [tables] = (await connection.execute(
      `SELECT table_name FROM information_schema.tables 
       WHERE table_schema = ? AND table_type = 'BASE TABLE'`,
      [database]
    )) as any[];

    console.log(`📊 Tables trouvées: ${tables.length}`);

    for (const table of tables) {
      const tableName = table.TABLE_NAME;

      // Structure de la table
      const [createTable] = (await connection.execute(
        `SHOW CREATE TABLE \`${tableName}\``
      )) as any[];

      sqlContent += `--\n-- Table structure for table \`${tableName}\`\n--\n\n`;
      sqlContent += `DROP TABLE IF EXISTS \`${tableName}\`;\n`;
      sqlContent += `${createTable[0]["Create Table"]};\n\n`;

      // Données de la table
      const [rows] = (await connection.execute(
        `SELECT * FROM \`${tableName}\``
      )) as any[];

      if (rows.length > 0) {
        sqlContent += `--\n-- Dumping data for table \`${tableName}\`\n--\n\n`;
        sqlContent += `LOCK TABLES \`${tableName}\` WRITE;\n`;

        for (const row of rows) {
          const columns = Object.keys(row)
            .map((col) => `\`${col}\``)
            .join(", ");
          const values = Object.values(row)
            .map((value) => {
              if (value === null) return "NULL";
              if (typeof value === "string")
                return `'${value.replace(/'/g, "''")}'`;
              if (value instanceof Date)
                return `'${value.toISOString().slice(0, 19).replace("T", " ")}'`;
              return value;
            })
            .join(", ");

          sqlContent += `INSERT INTO \`${tableName}\` (${columns}) VALUES (${values});\n`;
        }

        sqlContent += `UNLOCK TABLES;\n\n`;
      }
    }

    sqlContent += `SET FOREIGN_KEY_CHECKS=1;\n`;
    sqlContent += `-- Dump completed on ${new Date().toISOString()}\n`;

    // Écrire le fichier
    fs.writeFileSync(sqlFilePath, sqlContent, "utf8");
    const stats = fs.statSync(sqlFilePath);

    // Compter les enregistrements pour les métadonnées
    const recordCounts = {
      students: await prisma.student.count(),
      professors: await prisma.professeur.count(),
      users: await prisma.user.count(),
      ues: await prisma.ue.count(),
      enrollments: await prisma.enrollment.count(),
      assignments: await prisma.courseAssignment.count(),
      grades: await prisma.grade.count(),
      payments: await prisma.payment.count(),
      auditLogs: await prisma.auditLog.count(),
    };

    const totalRecords = Object.values(recordCounts).reduce((a, b) => a + b, 0);

    const backup = {
      filename: sqlFilename,
      size: stats.size,
      timestamp: new Date().toISOString(),
      records: recordCounts,
    };

    // Sauvegarder les métadonnées
    const metadataPath = path.join(backupDir, `${sqlFilename}.meta.json`);
    fs.writeFileSync(metadataPath, JSON.stringify(backup, null, 2));

    console.log(
      `✅ Sauvegarde créée: ${sqlFilename} (${stats.size} bytes, ${totalRecords} enregistrements)`
    );

    await AuditService.log({
      action: "CREATE_BACKUP",
      entity: "Backup",
      description: `Sauvegarde créée: ${sqlFilename}`,
      userId: (req as any).user?.id,
    });

    res.json({
      success: true,
      backup,
      message: "Sauvegarde créée avec succès",
    });
  } catch (error: any) {
    console.error("❌ Erreur création sauvegarde:", error);

    await AuditService.log({
      action: "CREATE_BACKUP_ERROR",
      entity: "Backup",
      description: `Erreur création sauvegarde`,
      userId: (req as any).user?.id,
      status: "ERROR",
    });

    res.status(500).json({
      error: "Erreur lors de la création de la sauvegarde",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  } finally {
    if (connection) {
      try {
        await connection.end();
      } catch (error) {
        console.error("Erreur fermeture connexion:", error);
      }
    }
  }
};

// Fonction d'export SQL simplifiée
export const exportSQL = async (req: Request, res: Response) => {
  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
    const backupDir = path.join(__dirname, "../../backups");

    if (!fs.existsSync(backupDir)) {
      fs.mkdirSync(backupDir, { recursive: true });
    }

    const filename = `export-academic-${timestamp}.sql`;
    const filepath = path.join(backupDir, filename);

    // Générer un export basique
    let sqlContent = `-- Academic System SQL Export\n`;
    sqlContent += `-- Generated: ${new Date().toISOString()}\n\n`;

    // Ajouter des informations système
    sqlContent += `-- Database Statistics:\n`;

    const counts = {
      students: await prisma.student.count(),
      professors: await prisma.professeur.count(),
      users: await prisma.user.count(),
      ues: await prisma.ue.count(),
    };

    for (const [table, count] of Object.entries(counts)) {
      sqlContent += `-- ${table}: ${count} records\n`;
    }

    sqlContent += `\n-- Export completed successfully\n`;

    fs.writeFileSync(filepath, sqlContent, "utf8");
    const stats = fs.statSync(filepath);

    await AuditService.log({
      action: "EXPORT_SQL",
      entity: "Database",
      description: `Export SQL réussi`,
      userId: (req as any).user?.id,
    });

    res.download(filepath, filename, (err) => {
      if (err) {
        console.error("Erreur téléchargement:", err);
      }
      // Nettoyer le fichier après envoi
      try {
        fs.unlinkSync(filepath);
      } catch (unlinkError) {
        console.error("Erreur suppression fichier:", unlinkError);
      }
    });
  } catch (error: any) {
    console.error("❌ Erreur export SQL:", error);

    await AuditService.log({
      action: "EXPORT_SQL_ERROR",
      entity: "Database",
      description: `Erreur export SQL`,
      userId: (req as any).user?.id,
      status: "ERROR",
    });

    res.status(500).json({
      error: "Erreur lors de l'export SQL",
    });
  }
};

export const downloadBackup = async (req: Request, res: Response) => {
  try {
    const { filename } = req.params;
    const backupDir = path.join(__dirname, "../../backups");

    // Chemin du fichier SQL
    const sqlFilePath = path.join(backupDir, filename);

    // Chemin du fichier de métadonnées
    const metadataPath = path.join(backupDir, `${filename}.meta.json`);

    console.log(`🔍 Recherche de la sauvegarde: ${filename}`);

    // Vérifier que le fichier SQL existe
    if (!fs.existsSync(sqlFilePath)) {
      console.error(`❌ Fichier SQL non trouvé: ${sqlFilePath}`);
      return res
        .status(404)
        .json({ error: "Fichier de sauvegarde non trouvé" });
    }

    const stats = fs.statSync(sqlFilePath);
    console.log(`✅ Fichier trouvé: ${filename} (${stats.size} bytes)`);

    // Lire les métadonnées si elles existent
    let metadata = null;
    if (fs.existsSync(metadataPath)) {
      try {
        metadata = JSON.parse(fs.readFileSync(metadataPath, "utf8"));
      } catch (error) {
        console.error("Erreur lecture métadonnées:", error);
      }
    }

    await AuditService.log({
      action: "DOWNLOAD_BACKUP",
      entity: "Backup",
      description: `Téléchargement sauvegarde: ${filename} (${stats.size} bytes)`,
      userId: (req as any).user?.id,
    });

    // Configurer les headers pour le téléchargement
    res.setHeader("Content-Type", "application/sql");
    res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
    res.setHeader("Content-Length", stats.size);
    res.setHeader(
      "X-Backup-Metadata",
      metadata ? JSON.stringify(metadata) : ""
    );

    // Stream le fichier SQL directement
    const fileStream = fs.createReadStream(sqlFilePath);

    fileStream.on("error", (error) => {
      console.error("❌ Erreur stream fichier:", error);
      res.status(500).json({ error: "Erreur lors du téléchargement" });
    });

    fileStream.pipe(res);
  } catch (error: any) {
    console.error("❌ Erreur téléchargement sauvegarde:", error);

    await AuditService.log({
      action: "DOWNLOAD_BACKUP_ERROR",
      entity: "Backup",
      description: `Erreur téléchargement sauvegarde: ${error.message}`,
      userId: (req as any).user?.id,
      status: "ERROR",
      errorMessage: error.message,
    });

    res.status(500).json({
      error: "Erreur lors du téléchargement de la sauvegarde",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

export const listBackups = async (req: Request, res: Response) => {
  try {
    const backupDir = path.join(__dirname, "../../backups");

    console.log(`🔍 Recherche des sauvegardes dans: ${backupDir}`);

    if (!fs.existsSync(backupDir)) {
      console.log("📁 Dossier de sauvegarde non trouvé, création...");
      fs.mkdirSync(backupDir, { recursive: true });
      return res.json({ backups: [] });
    }

    const files = fs.readdirSync(backupDir);
    const backups = [];
    let totalSize = 0;

    console.log(`📁 Fichiers trouvés: ${files.length}`);

    for (const file of files) {
      if (file.endsWith(".meta.json")) {
        const metaPath = path.join(backupDir, file);
        try {
          const metaData = JSON.parse(fs.readFileSync(metaPath, "utf8"));

          // Vérifier que le fichier SQL correspondant existe
          const sqlFilename = file.replace(".meta.json", "");
          const sqlFilePath = path.join(backupDir, sqlFilename);

          if (fs.existsSync(sqlFilePath)) {
            const stats = fs.statSync(sqlFilePath);
            metaData.size = stats.size; // Mettre à jour la taille réelle
            metaData.exists = true;
            backups.push(metaData);
            totalSize += stats.size;
          } else {
            console.warn(`⚠️ Fichier SQL manquant: ${sqlFilename}`);
            metaData.exists = false;
            backups.push(metaData);
          }
        } catch (error) {
          console.error(`❌ Erreur lecture metadata ${file}:`, error);
        }
      }
    }

    // Trier par date (plus récent en premier)
    backups.sort(
      (a, b) =>
        new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime()
    );

    const stats = {
      total: backups.length,
      totalSize,
      available: backups.filter((b) => b.exists).length,
      missing: backups.filter((b) => !b.exists).length,
    };

    console.log(`✅ ${backups.length} sauvegardes chargées`);

    res.json({ backups, stats });
  } catch (error: any) {
    console.error("❌ Erreur liste sauvegardes:", error);
    res.status(500).json({
      error: "Erreur lors de la récupération des sauvegardes",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

export const getBackupStats = async (req: Request, res: Response) => {
  try {
    const recordCounts = {
      students: await prisma.student.count(),
      professors: await prisma.professeur.count(),
      users: await prisma.user.count(),
      ues: await prisma.ue.count(),
      enrollments: await prisma.enrollment.count(),
      assignments: await prisma.courseAssignment.count(),
      grades: await prisma.grade.count(),
      payments: await prisma.payment.count(),
      auditLogs: await prisma.auditLog.count(),
    };

    const totalRecords = Object.values(recordCounts).reduce((a, b) => a + b, 0);

    // Statistiques des fichiers de sauvegarde
    const backupDir = path.join(__dirname, "../../backups");
    let backupStats: {
      total: number;
      totalSize: number;
      lastBackup: string | null;
    } = { total: 0, totalSize: 0, lastBackup: null };

    if (fs.existsSync(backupDir)) {
      const files = fs.readdirSync(backupDir);
      const sqlFiles = files.filter(
        (f) => f.endsWith(".sql") && !f.endsWith(".meta.json")
      );

      backupStats.total = sqlFiles.length;

      for (const file of sqlFiles) {
        const filePath = path.join(backupDir, file);
        const stats = fs.statSync(filePath);
        backupStats.totalSize += stats.size;
      }

      // Dernière sauvegarde
      if (sqlFiles.length > 0) {
        const latestFile = sqlFiles
          .map((f) => ({
            name: f,
            time: fs.statSync(path.join(backupDir, f)).mtime,
          }))
          .sort((a, b) => b.time.getTime() - a.time.getTime())[0];

        backupStats.lastBackup = latestFile.time.toISOString();
      }
    }

    res.json({
      database: {
        totalRecords,
        ...recordCounts,
      },
      backups: backupStats,
    });
  } catch (error: any) {
    console.error("❌ Erreur statistiques sauvegardes:", error);
    res.status(500).json({
      error: "Erreur lors de la récupération des statistiques",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};

// Nouvelle fonction pour supprimer une sauvegarde
export const deleteBackup = async (req: Request, res: Response) => {
  try {
    const { filename } = req.params;
    const backupDir = path.join(__dirname, "../../backups");

    const sqlFilePath = path.join(backupDir, filename);
    const metadataPath = path.join(backupDir, `${filename}.meta.json`);

    console.log(`🗑️ Suppression de la sauvegarde: ${filename}`);

    // Supprimer le fichier SQL
    if (fs.existsSync(sqlFilePath)) {
      fs.unlinkSync(sqlFilePath);
      console.log(`✅ Fichier SQL supprimé: ${filename}`);
    }

    // Supprimer les métadonnées
    if (fs.existsSync(metadataPath)) {
      fs.unlinkSync(metadataPath);
      console.log(`✅ Métadonnées supprimées: ${filename}.meta.json`);
    }

    await AuditService.log({
      action: "DELETE_BACKUP",
      entity: "Backup",
      description: `Sauvegarde supprimée: ${filename}`,
      userId: (req as any).user?.id,
    });

    res.json({
      success: true,
      message: "Sauvegarde supprimée avec succès",
    });
  } catch (error: any) {
    console.error("❌ Erreur suppression sauvegarde:", error);

    await AuditService.log({
      action: "DELETE_BACKUP_ERROR",
      entity: "Backup",
      description: `Erreur suppression sauvegarde: ${error.message}`,
      userId: (req as any).user?.id,
      status: "ERROR",
      errorMessage: error.message,
    });

    res.status(500).json({
      error: "Erreur lors de la suppression de la sauvegarde",
      details:
        process.env.NODE_ENV === "development" ? error.message : undefined,
    });
  }
};
