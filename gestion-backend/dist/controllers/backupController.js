"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.deleteBackup = exports.getBackupStats = exports.listBackups = exports.downloadBackup = exports.exportSQL = exports.createBackup = void 0;
// controllers/backupController.ts
const child_process_1 = require("child_process");
const util_1 = require("util");
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const auditService_1 = require("../services/auditService");
const prisma_1 = __importDefault(require("../prisma"));
const promise_1 = require("mysql2/promise");
const execAsync = (0, util_1.promisify)(child_process_1.exec);
const createBackup = async (req, res) => {
    let connection;
    try {
        const { name, modules } = req.body;
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const backupDir = path_1.default.join(__dirname, "../../backups");
        if (!fs_1.default.existsSync(backupDir)) {
            fs_1.default.mkdirSync(backupDir, { recursive: true });
        }
        const dbUrl = process.env.DATABASE_URL;
        if (!dbUrl) {
            return res.status(500).json({ error: "DATABASE_URL non configur√©e" });
        }
        const sqlFilename = name
            ? `backup-${name.replace(/[^a-zA-Z0-9]/g, "-")}-${timestamp}.sql`
            : `backup-academic-${timestamp}.sql`;
        const sqlFilePath = path_1.default.join(backupDir, sqlFilename);
        console.log(`üîß Cr√©ation de la sauvegarde MySQL (Node.js): ${sqlFilename}`);
        // Extraire les informations de connexion
        const urlMatch = dbUrl.match(/mysql:\/\/([^:]+):([^@]+)@([^:]+):(\d+)\/(.+)/);
        if (!urlMatch) {
            throw new Error("Format DATABASE_URL MySQL invalide");
        }
        const [, username, password, host, port, database] = urlMatch;
        // Cr√©er une connexion
        connection = await (0, promise_1.createConnection)({
            host,
            port: parseInt(port),
            user: username,
            password,
            database,
            charset: "utf8mb4",
        });
        let sqlContent = `-- MySQL dump generated by Academic System\n`;
        sqlContent += `-- Server version: Node.js MySQL2\n`;
        sqlContent += `-- Database: ${database}\n`;
        sqlContent += `-- Generation Time: ${new Date().toISOString()}\n\n`;
        sqlContent += `SET FOREIGN_KEY_CHECKS=0;\n\n`;
        // R√©cup√©rer la liste des tables
        const [tables] = (await connection.execute(`SELECT table_name FROM information_schema.tables 
       WHERE table_schema = ? AND table_type = 'BASE TABLE'`, [database]));
        console.log(`üìä Tables trouv√©es: ${tables.length}`);
        for (const table of tables) {
            const tableName = table.TABLE_NAME;
            // Structure de la table
            const [createTable] = (await connection.execute(`SHOW CREATE TABLE \`${tableName}\``));
            sqlContent += `--\n-- Table structure for table \`${tableName}\`\n--\n\n`;
            sqlContent += `DROP TABLE IF EXISTS \`${tableName}\`;\n`;
            sqlContent += `${createTable[0]["Create Table"]};\n\n`;
            // Donn√©es de la table
            const [rows] = (await connection.execute(`SELECT * FROM \`${tableName}\``));
            if (rows.length > 0) {
                sqlContent += `--\n-- Dumping data for table \`${tableName}\`\n--\n\n`;
                sqlContent += `LOCK TABLES \`${tableName}\` WRITE;\n`;
                for (const row of rows) {
                    const columns = Object.keys(row)
                        .map((col) => `\`${col}\``)
                        .join(", ");
                    const values = Object.values(row)
                        .map((value) => {
                        if (value === null)
                            return "NULL";
                        if (typeof value === "string")
                            return `'${value.replace(/'/g, "''")}'`;
                        if (value instanceof Date)
                            return `'${value.toISOString().slice(0, 19).replace("T", " ")}'`;
                        return value;
                    })
                        .join(", ");
                    sqlContent += `INSERT INTO \`${tableName}\` (${columns}) VALUES (${values});\n`;
                }
                sqlContent += `UNLOCK TABLES;\n\n`;
            }
        }
        sqlContent += `SET FOREIGN_KEY_CHECKS=1;\n`;
        sqlContent += `-- Dump completed on ${new Date().toISOString()}\n`;
        // √âcrire le fichier
        fs_1.default.writeFileSync(sqlFilePath, sqlContent, "utf8");
        const stats = fs_1.default.statSync(sqlFilePath);
        // Compter les enregistrements pour les m√©tadonn√©es
        const recordCounts = {
            students: await prisma_1.default.student.count(),
            professors: await prisma_1.default.professeur.count(),
            users: await prisma_1.default.user.count(),
            ues: await prisma_1.default.ue.count(),
            enrollments: await prisma_1.default.enrollment.count(),
            assignments: await prisma_1.default.courseAssignment.count(),
            grades: await prisma_1.default.grade.count(),
            payments: await prisma_1.default.payment.count(),
            auditLogs: await prisma_1.default.auditLog.count(),
        };
        const totalRecords = Object.values(recordCounts).reduce((a, b) => a + b, 0);
        const backup = {
            filename: sqlFilename,
            size: stats.size,
            timestamp: new Date().toISOString(),
            records: recordCounts,
        };
        // Sauvegarder les m√©tadonn√©es
        const metadataPath = path_1.default.join(backupDir, `${sqlFilename}.meta.json`);
        fs_1.default.writeFileSync(metadataPath, JSON.stringify(backup, null, 2));
        console.log(`‚úÖ Sauvegarde cr√©√©e: ${sqlFilename} (${stats.size} bytes, ${totalRecords} enregistrements)`);
        await auditService_1.AuditService.log({
            action: "CREATE_BACKUP",
            entity: "Backup",
            description: `Sauvegarde cr√©√©e: ${sqlFilename}`,
            userId: req.user?.id,
        });
        res.json({
            success: true,
            backup,
            message: "Sauvegarde cr√©√©e avec succ√®s",
        });
    }
    catch (error) {
        console.error("‚ùå Erreur cr√©ation sauvegarde:", error);
        await auditService_1.AuditService.log({
            action: "CREATE_BACKUP_ERROR",
            entity: "Backup",
            description: `Erreur cr√©ation sauvegarde`,
            userId: req.user?.id,
            status: "ERROR",
        });
        res.status(500).json({
            error: "Erreur lors de la cr√©ation de la sauvegarde",
            details: process.env.NODE_ENV === "development" ? error.message : undefined,
        });
    }
    finally {
        if (connection) {
            try {
                await connection.end();
            }
            catch (error) {
                console.error("Erreur fermeture connexion:", error);
            }
        }
    }
};
exports.createBackup = createBackup;
// Fonction d'export SQL simplifi√©e
const exportSQL = async (req, res) => {
    try {
        const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
        const backupDir = path_1.default.join(__dirname, "../../backups");
        if (!fs_1.default.existsSync(backupDir)) {
            fs_1.default.mkdirSync(backupDir, { recursive: true });
        }
        const filename = `export-academic-${timestamp}.sql`;
        const filepath = path_1.default.join(backupDir, filename);
        // G√©n√©rer un export basique
        let sqlContent = `-- Academic System SQL Export\n`;
        sqlContent += `-- Generated: ${new Date().toISOString()}\n\n`;
        // Ajouter des informations syst√®me
        sqlContent += `-- Database Statistics:\n`;
        const counts = {
            students: await prisma_1.default.student.count(),
            professors: await prisma_1.default.professeur.count(),
            users: await prisma_1.default.user.count(),
            ues: await prisma_1.default.ue.count(),
        };
        for (const [table, count] of Object.entries(counts)) {
            sqlContent += `-- ${table}: ${count} records\n`;
        }
        sqlContent += `\n-- Export completed successfully\n`;
        fs_1.default.writeFileSync(filepath, sqlContent, "utf8");
        const stats = fs_1.default.statSync(filepath);
        await auditService_1.AuditService.log({
            action: "EXPORT_SQL",
            entity: "Database",
            description: `Export SQL r√©ussi`,
            userId: req.user?.id,
        });
        res.download(filepath, filename, (err) => {
            if (err) {
                console.error("Erreur t√©l√©chargement:", err);
            }
            // Nettoyer le fichier apr√®s envoi
            try {
                fs_1.default.unlinkSync(filepath);
            }
            catch (unlinkError) {
                console.error("Erreur suppression fichier:", unlinkError);
            }
        });
    }
    catch (error) {
        console.error("‚ùå Erreur export SQL:", error);
        await auditService_1.AuditService.log({
            action: "EXPORT_SQL_ERROR",
            entity: "Database",
            description: `Erreur export SQL`,
            userId: req.user?.id,
            status: "ERROR",
        });
        res.status(500).json({
            error: "Erreur lors de l'export SQL",
        });
    }
};
exports.exportSQL = exportSQL;
const downloadBackup = async (req, res) => {
    try {
        const { filename } = req.params;
        const backupDir = path_1.default.join(__dirname, "../../backups");
        // Chemin du fichier SQL
        const sqlFilePath = path_1.default.join(backupDir, filename);
        // Chemin du fichier de m√©tadonn√©es
        const metadataPath = path_1.default.join(backupDir, `${filename}.meta.json`);
        console.log(`üîç Recherche de la sauvegarde: ${filename}`);
        // V√©rifier que le fichier SQL existe
        if (!fs_1.default.existsSync(sqlFilePath)) {
            console.error(`‚ùå Fichier SQL non trouv√©: ${sqlFilePath}`);
            return res
                .status(404)
                .json({ error: "Fichier de sauvegarde non trouv√©" });
        }
        const stats = fs_1.default.statSync(sqlFilePath);
        console.log(`‚úÖ Fichier trouv√©: ${filename} (${stats.size} bytes)`);
        // Lire les m√©tadonn√©es si elles existent
        let metadata = null;
        if (fs_1.default.existsSync(metadataPath)) {
            try {
                metadata = JSON.parse(fs_1.default.readFileSync(metadataPath, "utf8"));
            }
            catch (error) {
                console.error("Erreur lecture m√©tadonn√©es:", error);
            }
        }
        await auditService_1.AuditService.log({
            action: "DOWNLOAD_BACKUP",
            entity: "Backup",
            description: `T√©l√©chargement sauvegarde: ${filename} (${stats.size} bytes)`,
            userId: req.user?.id,
        });
        // Configurer les headers pour le t√©l√©chargement
        res.setHeader("Content-Type", "application/sql");
        res.setHeader("Content-Disposition", `attachment; filename="${filename}"`);
        res.setHeader("Content-Length", stats.size);
        res.setHeader("X-Backup-Metadata", metadata ? JSON.stringify(metadata) : "");
        // Stream le fichier SQL directement
        const fileStream = fs_1.default.createReadStream(sqlFilePath);
        fileStream.on("error", (error) => {
            console.error("‚ùå Erreur stream fichier:", error);
            res.status(500).json({ error: "Erreur lors du t√©l√©chargement" });
        });
        fileStream.pipe(res);
    }
    catch (error) {
        console.error("‚ùå Erreur t√©l√©chargement sauvegarde:", error);
        await auditService_1.AuditService.log({
            action: "DOWNLOAD_BACKUP_ERROR",
            entity: "Backup",
            description: `Erreur t√©l√©chargement sauvegarde: ${error.message}`,
            userId: req.user?.id,
            status: "ERROR",
            errorMessage: error.message,
        });
        res.status(500).json({
            error: "Erreur lors du t√©l√©chargement de la sauvegarde",
            details: process.env.NODE_ENV === "development" ? error.message : undefined,
        });
    }
};
exports.downloadBackup = downloadBackup;
const listBackups = async (req, res) => {
    try {
        const backupDir = path_1.default.join(__dirname, "../../backups");
        console.log(`üîç Recherche des sauvegardes dans: ${backupDir}`);
        if (!fs_1.default.existsSync(backupDir)) {
            console.log("üìÅ Dossier de sauvegarde non trouv√©, cr√©ation...");
            fs_1.default.mkdirSync(backupDir, { recursive: true });
            return res.json({ backups: [] });
        }
        const files = fs_1.default.readdirSync(backupDir);
        const backups = [];
        let totalSize = 0;
        console.log(`üìÅ Fichiers trouv√©s: ${files.length}`);
        for (const file of files) {
            if (file.endsWith(".meta.json")) {
                const metaPath = path_1.default.join(backupDir, file);
                try {
                    const metaData = JSON.parse(fs_1.default.readFileSync(metaPath, "utf8"));
                    // V√©rifier que le fichier SQL correspondant existe
                    const sqlFilename = file.replace(".meta.json", "");
                    const sqlFilePath = path_1.default.join(backupDir, sqlFilename);
                    if (fs_1.default.existsSync(sqlFilePath)) {
                        const stats = fs_1.default.statSync(sqlFilePath);
                        metaData.size = stats.size; // Mettre √† jour la taille r√©elle
                        metaData.exists = true;
                        backups.push(metaData);
                        totalSize += stats.size;
                    }
                    else {
                        console.warn(`‚ö†Ô∏è Fichier SQL manquant: ${sqlFilename}`);
                        metaData.exists = false;
                        backups.push(metaData);
                    }
                }
                catch (error) {
                    console.error(`‚ùå Erreur lecture metadata ${file}:`, error);
                }
            }
        }
        // Trier par date (plus r√©cent en premier)
        backups.sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());
        const stats = {
            total: backups.length,
            totalSize,
            available: backups.filter((b) => b.exists).length,
            missing: backups.filter((b) => !b.exists).length,
        };
        console.log(`‚úÖ ${backups.length} sauvegardes charg√©es`);
        res.json({ backups, stats });
    }
    catch (error) {
        console.error("‚ùå Erreur liste sauvegardes:", error);
        res.status(500).json({
            error: "Erreur lors de la r√©cup√©ration des sauvegardes",
            details: process.env.NODE_ENV === "development" ? error.message : undefined,
        });
    }
};
exports.listBackups = listBackups;
const getBackupStats = async (req, res) => {
    try {
        const recordCounts = {
            students: await prisma_1.default.student.count(),
            professors: await prisma_1.default.professeur.count(),
            users: await prisma_1.default.user.count(),
            ues: await prisma_1.default.ue.count(),
            enrollments: await prisma_1.default.enrollment.count(),
            assignments: await prisma_1.default.courseAssignment.count(),
            grades: await prisma_1.default.grade.count(),
            payments: await prisma_1.default.payment.count(),
            auditLogs: await prisma_1.default.auditLog.count(),
        };
        const totalRecords = Object.values(recordCounts).reduce((a, b) => a + b, 0);
        // Statistiques des fichiers de sauvegarde
        const backupDir = path_1.default.join(__dirname, "../../backups");
        let backupStats = { total: 0, totalSize: 0, lastBackup: null };
        if (fs_1.default.existsSync(backupDir)) {
            const files = fs_1.default.readdirSync(backupDir);
            const sqlFiles = files.filter((f) => f.endsWith(".sql") && !f.endsWith(".meta.json"));
            backupStats.total = sqlFiles.length;
            for (const file of sqlFiles) {
                const filePath = path_1.default.join(backupDir, file);
                const stats = fs_1.default.statSync(filePath);
                backupStats.totalSize += stats.size;
            }
            // Derni√®re sauvegarde
            if (sqlFiles.length > 0) {
                const latestFile = sqlFiles
                    .map((f) => ({
                    name: f,
                    time: fs_1.default.statSync(path_1.default.join(backupDir, f)).mtime,
                }))
                    .sort((a, b) => b.time.getTime() - a.time.getTime())[0];
                backupStats.lastBackup = latestFile.time.toISOString();
            }
        }
        res.json({
            database: {
                totalRecords,
                ...recordCounts,
            },
            backups: backupStats,
        });
    }
    catch (error) {
        console.error("‚ùå Erreur statistiques sauvegardes:", error);
        res.status(500).json({
            error: "Erreur lors de la r√©cup√©ration des statistiques",
            details: process.env.NODE_ENV === "development" ? error.message : undefined,
        });
    }
};
exports.getBackupStats = getBackupStats;
// Nouvelle fonction pour supprimer une sauvegarde
const deleteBackup = async (req, res) => {
    try {
        const { filename } = req.params;
        const backupDir = path_1.default.join(__dirname, "../../backups");
        const sqlFilePath = path_1.default.join(backupDir, filename);
        const metadataPath = path_1.default.join(backupDir, `${filename}.meta.json`);
        console.log(`üóëÔ∏è Suppression de la sauvegarde: ${filename}`);
        // Supprimer le fichier SQL
        if (fs_1.default.existsSync(sqlFilePath)) {
            fs_1.default.unlinkSync(sqlFilePath);
            console.log(`‚úÖ Fichier SQL supprim√©: ${filename}`);
        }
        // Supprimer les m√©tadonn√©es
        if (fs_1.default.existsSync(metadataPath)) {
            fs_1.default.unlinkSync(metadataPath);
            console.log(`‚úÖ M√©tadonn√©es supprim√©es: ${filename}.meta.json`);
        }
        await auditService_1.AuditService.log({
            action: "DELETE_BACKUP",
            entity: "Backup",
            description: `Sauvegarde supprim√©e: ${filename}`,
            userId: req.user?.id,
        });
        res.json({
            success: true,
            message: "Sauvegarde supprim√©e avec succ√®s",
        });
    }
    catch (error) {
        console.error("‚ùå Erreur suppression sauvegarde:", error);
        await auditService_1.AuditService.log({
            action: "DELETE_BACKUP_ERROR",
            entity: "Backup",
            description: `Erreur suppression sauvegarde: ${error.message}`,
            userId: req.user?.id,
            status: "ERROR",
            errorMessage: error.message,
        });
        res.status(500).json({
            error: "Erreur lors de la suppression de la sauvegarde",
            details: process.env.NODE_ENV === "development" ? error.message : undefined,
        });
    }
};
exports.deleteBackup = deleteBackup;
